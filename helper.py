import numpy as np
import matplotlib.pyplot as plt
import settings
import cv2
from image_detection import detect_colored_cups
import genesis as gs
import math 

#-----------------------------------------------------------------------
#   DEBUGGING FUNCTIONS
#-----------------------------------------------------------------------
def checkpoint(franka, phase_name):
    pos = franka.get_link('hand').get_pos().cpu().numpy()
    angle = math.degrees(get_current_angle(franka))
    print(f"[[{phase_name.upper()}]] Pos: {pos}, Angle: {angle:.4f}")

def add_coordinate_frame(scene, pos=(0, 0, 0), length=0.3, radius=0.01, label=""):
    # X-axis (red), Y-axis (green), Z-axis (Blue)
    x, y, z = pos
    scene.add_entity(
        gs.morphs.Cylinder(
            pos=(x + length/2, y, z),
            radius=radius,
            height=length,
            euler=(0, 90, 0),
            fixed=True,
        ),
        surface=gs.surfaces.Default(color=(1, 0, 0), vis_mode='visual')
    )
    scene.add_entity(
        gs.morphs.Cylinder(
            pos=(x, y + length/2, z),
            radius=radius,
            height=length,
            euler=(90, 0, 0),
            fixed=True,
        ),
        surface=gs.surfaces.Default(color=(0, 1, 0), vis_mode='visual')
    )
    scene.add_entity(
        gs.morphs.Cylinder(
            pos=(x, y, z + length/2),
            radius=radius,
            height=length,
            fixed=True,
        ),
        surface=gs.surfaces.Default(color=(0, 0, 1), vis_mode='visual')
    )
    
    if label:
        print(f"Added coordinate frame '{label}' at {pos} \n")

#-----------------------------------------------------------------------
#   COMPUTER VISION FUNCTIONS
#-----------------------------------------------------------------------
'''
Camera Calibrations:
INTRINSIC MATRIX 
[[277.12812921   0.         160.        ]
 [  0.         277.12812921 160.        ]
 [  0.           0.           1.        ]]
TRANSFORMATION MATRIX 
[[ 1.    0.    0.    0.65]
 [ 0.    0.   -1.   -0.5 ]
 [ 0.    1.    0.    0.  ]
 [ 0.    0.    0.    1.  ]]


Execution pipeline:
media_pipe creates a bouding box around the cup and gives the coordiates of the box
we find the center of the box or the bottom of the box (1x3 image coordinate)
we input the 1x3 image coordinates into this function, which returns 1x3 world coordinates
we input the world coordinates into the approach function
'''

# '''
# TODO: this is to find extrinsic matrix but it's currently not current
# this funtion returns R: 
# [[-1, 0, 0]
#  [ 0, 1, 0]
#  [ 0, 0, 1]]
# should be:
# [[ 1.,  0.,  0.], 
#  [ 0.,  0., -1.],
#  [ 0.,  1.,  0.]]
# '''
# def look_at_transform(pos, lookat, up):
#     '''
#     Generate the extrinsic matrix (world to camera)
#     TODO: adjust so that lookat is at CUP3 (the one that's not moving)
#     '''
#     pos = np.array(pos)
#     lookat = np.array(lookat)
#     up = np.array(up)
#     # forward vector (camera points toward +Y)
#     f = lookat - pos # y axis
#     f = f / np.linalg.norm(f)
#     # left vector  (-X direction)
#     l = np.cross(f, up) 
#     l = l / np.linalg.norm(l)
#     # recompute true up vector
#     u = np.cross(l, f)
#     # Genesis cameras look down -Z
#     T = np.eye(4)
#     T[:3, 0] = -l       # X axis
#     T[:3, 1] = f       # Y axis
#     T[:3, 2] = u       # Z axis (camera forward is -Z)
#     T[:3, 3] = pos     # position
#     return T

# def compute_camera_rotation(pos, lookat, up_hint): # generated by Chat, need to validate 
#     pos = np.array(pos, float)
#     lookat = np.array(lookat, float)
#     up_hint = np.array(up_hint, float)
#     # +Z forward
#     f = lookat - pos
#     f = f / np.linalg.norm(f)
#     # +X right
#     r = np.cross(f, up_hint)
#     r = r / np.linalg.norm(r)
#     # recompute +Y up (orthogonalized)
#     u = np.cross(r, f)
#     # Construct rotation: columns are r, u, f
#     R_c2w = np.column_stack((r, u, f))
#     return R_c2w

# def depth_image_to_camera_frame(K, image_x, image_y, depth):
#     fx = K[0,0]
#     fy = K[1,1]
#     cx = K[0,2]
#     cy = K[1,2]
#     x = (image_x - cx) * depth / fx
#     y = (image_y - cy) * depth / fy
#     return np.array([x, y, depth])

# ------------- get camera images ----------------
def get_camera_render(cam):
    '''
    returns an array of dictionaries containing the various colors of cups we detect as well as a depth array
    for example {"red":[(cx,cy),...], "blue":[...], ...}
    {'red': [(243, 126)], 'green': [], 'blue': [(76, 126)]}
    '''
    rgb_arr, depth_arr, seg_arr, normal_arr = cam.render(depth=True)
    bgr_frame = cv2.cvtColor(rgb_arr, cv2.COLOR_RGB2BGR)
    cups = detect_colored_cups(bgr_frame)
    print(cups)
    gray = cv2.cvtColor(rgb_arr, cv2.COLOR_BGR2GRAY)

    if len(cups["red"]) > 0:
        red_cup_x = cups["red"][0][0]
        red_cup_y = cups["red"][0][1]
        plt.plot(red_cup_x, red_cup_y, 'ro') 
    if len(cups["blue"]) > 0:
        blue_cup_x = cups["blue"][0][0]
        blue_cup_y = cups["blue"][0][1]
        plt.plot(blue_cup_x, blue_cup_y, 'bo') 
    plt.imshow(gray)
    plt.show()
    
    return cups, depth_arr

camera_position = np.array([settings.CAM_POS[0], settings.CAM_POS[1], settings.CAM_POS[2]])
# camera_position = np.array([0.55, 0.5, 0.]) #x->x, y->-z, z->y
R_cam_to_world = np.array([
    [1,  0,  0],  # camera X → world X
    [0,  0, 1],  # camera Y → world -Z
    [0,  1,  0]   # camera Z → world Y
])
def pixel_to_world(K, u, v, depth=1.0):
    """
    Transform pixel coordinates to world coordinates.
    
    Args:
        u, v: pixel coordinates (0 to 319)
        depth: depth value at that pixel (in meters)
    
    Returns:
        world_point: 3D point in world coordinates [x, y, z]
    """
    fx = K[0,0]
    fy = K[1,1]
    cx = K[0,2]
    cy = K[1,2]

    x_cam = (u - cx) * depth / fx
    y_cam = -(v - cy) * depth / fy
    z_cam = depth
    
    point_in_camera = np.array([x_cam, y_cam, z_cam])
    print("POINT IN CAMERA:", point_in_camera)
    
    point_in_world = R_cam_to_world @ point_in_camera + camera_position
    
    return point_in_world    

#-----------------------------------------------------------------------
#   ANALYSIS FUNCTIONS
#-----------------------------------------------------------------------
def count_particles_in_cup(cup, liquid, cup_height, cup_radius):
    """
    Count how many liquid particles are inside cup2's cylindrical bounds.
    """
    # Get particle positions (shape: [n_particles, 3])
    particle_pos = liquid.get_particles_pos().cpu().numpy()
    # print("PARTICLE POS SHAPE:", particle_pos.shape)
    # print("PARTICLE POS:", particle_pos)
    # Get cup2's current position
    cup_pos = cup.get_pos().cpu().numpy()
    
    # Calculate relative positions (x, y, z) from cup2 center
    rel_pos = particle_pos - cup_pos
    
    # Check cylinder bounds:
    # 1. Radial distance from cup2's center (x-y plane)
    radial_dist = np.sqrt(rel_pos[:, 0]**2 + rel_pos[:, 1]**2)
    
    # 2. Height within cup (z axis) - cup opening at top
    # Assuming cup is upright with opening at +z direction
    z_min = -cup_height / 2  # bottom of cup
    z_max = cup_height / 2   # top of cup (opening)
    
    # Particles are inside if:
    # - radial distance < radius
    # - z is between bottom and top
    inside_radially = radial_dist < cup_radius
    inside_vertically = (rel_pos[:, 2] > z_min) & (rel_pos[:, 2] < z_max)
    
    particles_inside = np.sum(inside_radially & inside_vertically)
    
    return particles_inside, len(particle_pos)

#-----------------------------------------------------------------------
#   MOTOR FUNCTIONS
#-----------------------------------------------------------------------
motors_dof  = np.arange(7)
fingers_dof = np.arange(7, 9)
target_pos = np.array(settings.TARGET_CUP_START_POS) - np.array([0.0, 0.0, 0.03])
approach_dir = np.array([0.0, 1.0, 0.0])  # approach from +Y toward -Y

def mat_to_quat_wxyz(R):
    """Rotation matrix → quaternion [w,x,y,z]."""
    m00,m01,m02 = R[0,0], R[0,1], R[0,2]
    m10,m11,m12 = R[1,0], R[1,1], R[1,2]
    m20,m21,m22 = R[2,0], R[2,1], R[2,2]
    tr = m00 + m11 + m22
    if tr > 0:
        S = np.sqrt(tr + 1.0) * 2
        w = 0.25 * S
        x = (m21 - m12) / S
        y = (m02 - m20) / S
        z = (m10 - m01) / S
    elif (m00 > m11) and (m00 > m22):
        S = np.sqrt(1.0 + m00 - m11 - m22) * 2
        w = (m21 - m12) / S
        x = 0.25 * S
        y = (m01 + m10) / S
        z = (m02 + m20) / S
    elif m11 > m22:
        S = np.sqrt(1.0 + m11 - m00 - m22) * 2
        w = (m02 - m20) / S
        x = (m01 + m10) / S
        y = 0.25 * S
        z = (m12 + m21) / S
    else:
        S = np.sqrt(1.0 + m22 - m00 - m11) * 2
        w = (m10 - m01) / S
        x = (m02 + m20) / S
        y = (m12 + m21) / S
        z = 0.25 * S
    return np.array([w,x,y,z])

def unit(v):
    v = np.array(v, dtype=float)
    n = np.linalg.norm(v)
    return v if n == 0 else v / n

def side_grasp_quat(approach_dir_world, up_hint_world=np.array([0,0,1]), order="wxyz"):
    """
    Build an orientation so hand -Z points along approach_dir_world.
    'up_hint_world' controls roll (jaws vertical if up=[0,0,1]).
    """
    z_hand = -unit(approach_dir_world)
    x_hand = unit(up_hint_world - np.dot(up_hint_world, z_hand) * z_hand)
    y_hand = np.cross(z_hand, x_hand)
    R = np.column_stack([x_hand, y_hand, z_hand])
    q_wxyz = mat_to_quat_wxyz(R)
    if order == "wxyz":
        return q_wxyz
    else:
        w,x,y,z = q_wxyz
        return np.array([x,y,z,w])
    
side_quat = side_grasp_quat(approach_dir, np.array([0,0,1]), order="wxyz")
pregrasp_offset  = 0.24 # distance between grasp setup and actual grasp
gripper_offset = np.array([0.0, 0.10, 0.0]) # offset from center of end-effector to center of grip
retreat_distance = 0 # 0.16
open_width  = 0.06
close_force = -0.2 # was -0.2 before

def approach(scene, franka, cup_pos):
    # -- set up for approach
    target_pos = np.array(cup_pos) + np.array([0.0, 0.0, -0.05]) # just below the center of the cup
    pregrasp_pos = target_pos + (approach_dir * pregrasp_offset)
    grasp_pos    = target_pos.copy() + gripper_offset
    print("- Target, ", target_pos)
    print("- Pregrasp, ", pregrasp_pos)
    print("- Grasp pos, ", grasp_pos)

    end_effector = franka.get_link('hand')
    q_pre = franka.inverse_kinematics(
            link=end_effector, 
            pos=pregrasp_pos, 
            quat=side_quat
    )
    q_pre[-2:] = open_width #open end-effector

    path = franka.plan_path(qpos_goal=q_pre, num_waypoints=500)
    for wp in path:
        franka.control_dofs_position(wp)
        scene.step()
    # ------------- approach ----------------
    for _ in range(80): scene.step()
    n_cart_steps_in = 200 #20
    for i in range(1, n_cart_steps_in + 1):
        a = i / n_cart_steps_in
        p = (1 - a) * pregrasp_pos + a * grasp_pos # straight line interpolation
        q = franka.inverse_kinematics(link=end_effector, pos=p, quat=side_quat)
        q[-2:] = open_width # last two joints are gripper positions, so this just keeps gripper open
        franka.control_dofs_position(q)
        scene.step()
    for _ in range(20): scene.step()

# ------------- grasp ----------------
def grasp(scene, franka):
    franka.control_dofs_force(np.array([close_force, close_force]), fingers_dof)
    for _ in range(70): scene.step() # before it was 140

def ungrasp(scene, franka):
    n_steps = 40
    
    for i in range(n_steps):
        if i == 0:
            franka.control_dofs_position([0.1, 0.1], fingers_dof)
        if i == (n_steps // 2):
            franka.control_dofs_position([0.2, 0.2], fingers_dof)
        scene.step()
    for _ in range(70): scene.step() # before it was 140

# ------------- lift ----------------
def lift(scene, franka, cup_pos, lift_height):
    '''
    lift function lifts franka lift_height relative to where it currently is.
    '''
    end_effector = franka.get_link('hand')
    
    target_pos = np.array(cup_pos) + np.array([0.0, 0.0, 0.09])
    current_pos = end_effector.get_pos().cpu().numpy()
    grasp_pos    = target_pos.copy() + gripper_offset
    new_grasp_pos = np.array([grasp_pos[0], grasp_pos[1], current_pos[2] + lift_height])
    n_move_steps = 100
    for i in range(n_move_steps):
        alpha = i / n_move_steps
        intermediate_pos = (1 - alpha) * current_pos + alpha * new_grasp_pos
        q_lift = franka.inverse_kinematics(
            link=end_effector,
            pos=intermediate_pos,
            quat=side_quat,
        )
        franka.control_dofs_position(q_lift[:-2], motors_dof)
        scene.step()
    for _ in range(100):
        scene.step()

def move_dist(scene, franka, direction, dist, n_move_steps=50):
    '''
    direction = 0, 1, 2 to represent x, y, z respectively

    dist is the distance 
    '''
    end_effector = franka.get_link('hand')
    current_pos = end_effector.get_pos().cpu().numpy()
    target_pos_closer = current_pos.copy()
    target_pos_closer[direction] += dist  # move dist in +direction
    # n_move_steps = 50

    for i in range(n_move_steps):
        alpha = i / n_move_steps
        intermediate_pos = (1 - alpha) * current_pos + alpha * target_pos_closer
        
        q_move = franka.inverse_kinematics(
            link=end_effector,
            pos=intermediate_pos,
            quat=side_quat,
        )
        
        franka.control_dofs_position(q_move[:-2], motors_dof)
        scene.step()
    
    for _ in range(30):
        scene.step()

def get_current_angle(franka):
    joint7_idx = 6
    return franka.get_dofs_position([joint7_idx]).cpu().numpy()[0]

# ------------- rotate to pour ----------------
def rotate(scene, franka, pour_level, direction=1):
    '''
    direction = 1 for clockwise, -1 for counterclockwise
    pour_level = "high", "medium", "low"
    '''
    joint7_idx = 6
    current_angle = get_current_angle(franka)
    # limits = franka.get_dof_limits([joint7_idx])
    # print(f"Joint 7 limits: {limits}")

    print("- CURRENT ANGLE:", current_angle)
    target_angle = direction*settings.POUR_LEVELS[pour_level]
    # the commented out code below doesn't work
    # if direction == -1:
    #     target_angle = current_angle + abs(target_angle)
    # else:
    #     target_angle = current_angle - abs(target_angle)
    print("- TARGET ANGLE:", target_angle)
    n_steps = settings.POUR_SPEED[pour_level]  # More steps = slower rotation

    for i in range(n_steps):
        # Smoothly interpolate from current to target angle
        alpha = i / n_steps
        intermediate_angle = (1 - alpha) * current_angle + alpha * target_angle
        # print("intermediate angle:", intermediate_angle)
        franka.control_dofs_position(
            np.array([intermediate_angle]),
            np.array([joint7_idx]),
        )
        scene.step()

    for _ in range(50):
        scene.step()

    for i in range(100):
        if i == 0:
            franka.control_dofs_position(
                np.array([0]),          # target angle in radians
                np.array([joint7_idx]),   # which joint to command
            )
        # print("control force:", franka.get_dofs_control_force([joint7_idx]))
        scene.step()

    for _ in range(40):
        scene.step()

# ------------- move circularly to stir ----------------
def stir(scene, franka):
    # lower the rod into the liquid
    end_effector = franka.get_link('hand')
    n_move_steps = 50

    center = np.array([0.5, 0.0, 0.4])   # choose a center in world coordinates
    radius = 0.05                         # circle radius
    start_angle = 0.0
    end_angle   = 2 * np.pi               # full circle; change for arc


    for i in range(n_move_steps):
        alpha = i / n_move_steps
        theta = start_angle + alpha * (end_angle - start_angle)
    
        # Circle in XY plane around `center`, constant Z
        intermediate_pos = np.array([
            center[0] + radius * np.cos(theta),
            center[1] + radius * np.sin(theta),
            center[2],                     # keep height fixed
        ])

        q_move = franka.inverse_kinematics(
            link=end_effector,
            pos=intermediate_pos,
            quat=side_quat,
        )

        franka.control_dofs_position(q_move[:-2], motors_dof)
        scene.step()
    
    for _ in range(30):
        scene.step()

def pour_drink(scene, franka, mixer_name, cup_entity, cam, pour_level, index, next_mixer_name=None):
    cups, depth = get_camera_render(cam)
    
    mixer_cup_x = cups[mixer_name][0][0]
    mixer_cup_y = cups[mixer_name][0][1]

    K = cam.intrinsics
    
    cup_pos = pixel_to_world(K, mixer_cup_x, mixer_cup_y)
    print(f"{mixer_name} CUP POS WORLD COORDINATES: {cup_pos}")
    print("TRUE MID LEFT CUP START POS", settings.MID_LEFT_CUP_START_POS)
    print("TRUE MID RIGHT CUP START POS", settings.MID_RIGHT_CUP_START_POS)


    move_off_shelf_dist = 0.12

    checkpoint(franka, "Pre Approach")
    approach(scene, franka, cup_pos)
    checkpoint(franka, "After Approach")
    grasp(scene, franka)
    checkpoint(franka, "After Grasp")
    move_dist(scene, franka, 2, 0.02) # lift it off the table
    checkpoint(franka, "After Lift Up")
    move_dist(scene, franka, 1, move_off_shelf_dist)  # move it off the shelf
    checkpoint(franka, "After Move Off Shelf")
    current_position = cup_entity.get_pos().cpu().numpy()
    lift(scene, franka, current_position, settings.LIFT_HEIGHT)
    checkpoint(franka, "After Lift")
    move_dist(scene, franka, 1, -move_off_shelf_dist)  # move it back on the shelf to pour in target cup
    checkpoint(franka, "After Move Back to Shelf")

    # if abs(get_current_angle(franka) - 1.7098901) < 0.001:
    #     # right cup is picked up, will pour cw 
    #     dist_to_move = settings.RIGHT_POUR_LOC_X - current_position[0]
    # else:
    #     # left cup is picked up, will pour ccw
    #     dist_to_move = settings.LEFT_POUR_LOC_X - current_position[0]
    dist_to_move = settings.POUR_LOCATION[0] - current_position[0]
    print("DIST TO MOVE", dist_to_move)
    move_dist(scene, franka, 0, dist_to_move) # move towards target cup
    checkpoint(franka, "Before Pour")
    rotate(scene, franka, pour_level, 1)
    checkpoint(franka, "After Pour")
    move_dist(scene, franka, 1, move_off_shelf_dist)  # move it off the shelf
    move_dist(scene, franka, 0, -dist_to_move) 
    
    lift(scene, franka, cup_entity.get_pos().cpu().numpy(), -settings.LIFT_HEIGHT + 0.07)
    move_dist(scene, franka, 1, -move_off_shelf_dist)  # move it back on the shelf
    ungrasp(scene, franka)
    move_dist(scene, franka, 1, move_off_shelf_dist)

    # if next_mixer_name is not None:
    #     #adjusting for next mixer
    #     print("ADJUSTING FOR NEXT MIXER")
    #     next_mixer_cup_x = cups[next_mixer_name][0][0]
    #     next_mixer_cup_y = cups[next_mixer_name][0][1]
    #     next_cup_pos = pixel_to_world(K, next_mixer_cup_x, next_mixer_cup_y)
    #     move_distance = next_cup_pos[0] - cup_entity.get_pos().cpu().numpy()[0]
    #     move_dist(scene, franka, 1, 0.3, 100)
    #     move_dist(scene, franka, 0, move_distance, 100)
